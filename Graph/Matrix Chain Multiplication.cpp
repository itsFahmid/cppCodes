#include <bits/stdc++.h>
using namespace std;

// Algorithm 1: MATRIX-CHAIN-ORDER

/**
 * A structure to hold the results of the matrix chain order calculation.
 */
struct MatrixChainResult {
    vector<vector<int>> m; // Minimum costs table
    vector<vector<int>> s; // Optimal split points table
};

/**
 * Solves the matrix-chain multiplication problem using dynamic programming.
 * A vector where p[i-1] and p[i] are the dimensions of matrix A_i.
 * A struct containing the cost table (m) and the split table (s).
 */
MatrixChainResult matrixChainOrder(const vector<int>& p) {
    int n = p.size() - 1;

    // Use 1-based indexing to match the pseudocode
    vector<vector<int>> m(n + 1, vector<int>(n + 1, 0));
    vector<vector<int>> s(n + 1, vector<int>(n + 1, 0));

    // 'l' is the chain length
    for (int l = 2; l <= n; ++l) {
        for (int i = 1; i <= n - l + 1; ++i) {
            int j = i + l - 1;
            m[i][j] = numeric_limits<int>::max();
            // 'k' is the split point
            for (int k = i; k <= j - 1; ++k) {
                // Cost formula
                int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (q < m[i][j]) {
                    m[i][j] = q;
                    s[i][j] = k;
                }
            }
        }
    }
    return {m, s};
}

// --- Algorithm 2: PRINT-OPTIMAL-PARENS ---

/**
 * Prints the optimal parenthesization of a matrix chain product.
 * The split table generated by matrixChainOrder.
 * The starting index of the subchain.
 * The ending index of the subchain.
 */
void printOptimalParens(const vector<vector<int>>& s, int i, int j) {
    // Base case: only one matrix
    if (i == j) {
        cout << "A" << i;
    }
    // Recursive step
    else {
        cout << "(";
        printOptimalParens(s, i, s[i][j]);
        printOptimalParens(s, s[i][j] + 1, j);
        cout << ")";
    }
}

// Algorithm 3: MATRIX-MULTIPLY

/**
 * Multiplies two matrices A (p x q) and B (q x r).
 * The first matrix.
 * The second matrix.
 * The resulting matrix C (p x r).
 */
vector<vector<int>> matrixMultiply(const vector<vector<int>>& A,
                                   const vector<vector<int>>& B) {
    if (A.empty() || B.empty() || A[0].size() != B.size()) {
        // Return an empty matrix if dimensions are incompatible
        return {};
    }

    int p = A.size();
    int q = B.size(); // or A[0].size()
    int r = B[0].size();

    vector<vector<int>> C(p, vector<int>(r, 0));

    // Note: C++ uses 0-based indexing, so loops run from 0 to size-1
    for (int i = 0; i < p; ++i) {
        for (int j = 0; j < r; ++j) {
            C[i][j] = 0;
            for (int k = 0; k < q; ++k) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return C;
}

// Main Program to Demonstrate Usage

int main() {
    // Example from CLRS book for a chain of 6 matrices (A1...A6).
    // Dimensions: 30x35, 35x15, 15x5, 5x10, 10x20, 20x25.
    vector<int> p = {30, 35, 15, 5, 10, 20, 25};
    int n = p.size() - 1;

    cout << "Running MATRIX-CHAIN-ORDER\n";
    MatrixChainResult result = matrixChainOrder(p);

    cout << "\nMinimum number of scalar multiplications: "
              << result.m[1][n] << "\n";

    cout << "\nCost Table (m):\n";
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(j >= i) cout << result.m[i][j] << "\t";
            else cout << "-\t";
        }
        cout << "\n";
    }

    cout << "\nSplit Table (s):\n";
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(j > i) cout << result.s[i][j] << "\t";
            else cout << "-\t";
        }
        cout << "\n";
    }

    cout << "\n##Running PRINT-OPTIMAL-PARENS\n";
    cout << "\nOptimal Parenthesization: ";
    printOptimalParens(result.s, 1, n);
    cout << "\n";

    return 0;
}
